<!--
  ============================================================
  Project: Glass Bridge Survival
  Created by Jay
  AI City Builders & Connect AI LAB
  ============================================================
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Glass Bridge Survival</title>
  <style>
    /* ── Reset ── */
    *,
    *::before,
    *::after {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
      font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      color: #fff;
    }

    canvas {
      display: block;
    }

    /* ── HUD ── */
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      gap: 40px;
      padding: 18px 24px;
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      z-index: 10;
      pointer-events: none;
      text-shadow: 0 0 12px rgba(0, 255, 200, .6);
    }

    #hud span {
      color: #00ffc8;
    }

    /* ── Overlays ── */
    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      /* hidden by default */
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      background: rgba(0, 0, 0, .82);
      backdrop-filter: blur(6px);
    }

    .overlay.active {
      display: flex;
    }

    .overlay h1 {
      font-size: 64px;
      letter-spacing: 6px;
      text-transform: uppercase;
      margin-bottom: 20px;
    }

    .overlay p {
      font-size: 22px;
      opacity: .8;
      margin-bottom: 32px;
    }

    .overlay button {
      padding: 14px 40px;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      border: 2px solid #00ffc8;
      background: transparent;
      color: #00ffc8;
      cursor: pointer;
      border-radius: 4px;
      transition: background .25s, color .25s;
    }

    .overlay button:hover {
      background: #00ffc8;
      color: #000;
    }

    #overlay-success h1 {
      color: #00ffc8;
    }

    #overlay-gameover h1 {
      color: #ff4060;
    }

    /* ── Start Screen ── */
    #overlay-start {
      /* display: flex;  <-- REMOVED: This was overriding the class toggle! */
    }

    #overlay-start h1 {
      color: #00ffc8;
      font-size: 48px;
      text-align: center;
      line-height: 1.3;
    }

    #overlay-start .subtitle {
      font-size: 16px;
      opacity: .55;
      margin-top: 6px;
    }

    /* ── Footer ── */
    #footer {
      position: fixed;
      bottom: 10px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 12px;
      opacity: .35;
      z-index: 30;
      pointer-events: none;
      font-family: 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
      letter-spacing: .5px;
    }
  </style>
</head>

<body>

  <!-- HUD -->
  <div id="hud">
    <div>LIVES: <span id="hud-lives">3</span></div>
    <div>STEP: <span id="hud-step">0</span>/10</div>
  </div>

  <!-- Start overlay -->
  <div id="overlay-start" class="overlay active">
    <h1>Glass Bridge<br>Survival</h1>
    <p class="subtitle">Participant 107 — Choose wisely.</p>
    <p>Click a glass panel to jump. Survive 10 rows.</p>
    <button id="btn-start">START GAME</button>
  </div>

  <!-- Success overlay -->
  <div id="overlay-success" class="overlay">
    <h1>SUCCESS</h1>
    <p>You crossed the bridge alive!</p>
    <button id="btn-replay-win">PLAY AGAIN</button>
  </div>

  <!-- Game Over overlay -->
  <div id="overlay-gameover" class="overlay">
    <h1>FAIL</h1>
    <p>Do you want to retry?</p>
    <button id="btn-replay-lose">RETRY</button>
  </div>

  <!-- Footer -->
  <div id="footer">ⓒ JunoMinu Company. All rights reserved.</div>



  <!-- Error Log Overlay -->
  <div id="error-log"
    style="display:none; position:fixed; top:0; left:0; right:0; background:rgba(255,0,0,0.9); color:white; padding:20px; z-index:9999; font-family:monospace; white-space:pre-wrap;">
  </div>

  <!-- Waterfall Loader Script -->
  <script>
    // Global Error Handler
    window.onerror = function (msg, url, line) {
      const log = document.getElementById('error-log');
      log.style.display = 'block';
      log.textContent += `Error: ${msg}\nLine: ${line}\n\n(Reload page to retry)`;
    };

    const threeCdns = [
      'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js',
      'https://unpkg.com/three@0.128.0/build/three.min.js',
      'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js'
    ];

    function loadScriptSequence(index) {
      if (index >= threeCdns.length) {
        alert("Three.js 로드 실패! 인터넷 연결을 확인하거나 방화벽 설정을 확인해주세요.\n(All libraries failed to load)");
        return;
      }
      console.log("Attempting to load Three.js from:", threeCdns[index]);
      const script = document.createElement('script');
      script.src = threeCdns[index];
      script.onload = function () {
        console.log("Success! Three.js loaded from:", threeCdns[index]);
        if (window.initApp) window.initApp();
      };
      script.onerror = function () {
        console.warn("Failed to load from:", threeCdns[index], "- trying next...");
        loadScriptSequence(index + 1);
      };
      document.head.appendChild(script);
    }

    // Start loading
    loadScriptSequence(0);
  </script>

  <script>
    /*
      ============================================================
      Project: Glass Bridge Survival
      Created by Jay
      AI City Builders & Connect AI LAB
      ============================================================
    */

    // ─────────────────────────────────────────────
    //  MAIN APP WRAPPER
    // ─────────────────────────────────────────────
    window.initApp = function () {
      console.log("Initializing Game App...");

      // ─────────────────────────────────────────────
      //  CONSTANTS
      // ─────────────────────────────────────────────
      const ROWS = 10;
      const COLS = 2;
      const PANEL_SIZE = 1.6;
      const GAP_Z = 2.6;      // spacing between rows in Z
      const COL_OFFSET = 1.8;      // half‑distance between left/right col
      const BRIDGE_Y = 0;         // Y of the bridge surface
      const START_Z = 4;         // player start Z (Moved back from 2)
      const JUMP_DURATION = 0.45;    // seconds

      // ─────────────────────────────────────────────
      //  STATE
      // ─────────────────────────────────────────────
      let lives, currentStep, gameActive, jumping;
      let bridgeData = [];  // [{leftSafe: bool, meshLeft, meshRight}]

      // DOM refs
      const hudLives = document.getElementById('hud-lives');
      const hudStep = document.getElementById('hud-step');
      const startOvl = document.getElementById('overlay-start');
      const successOvl = document.getElementById('overlay-success');
      const gameoverOvl = document.getElementById('overlay-gameover');

      // ─────────────────────────────────────────────
      //  THREE.JS SETUP
      // ─────────────────────────────────────────────
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      scene.fog = new THREE.FogExp2(0x000000, 0.02);

      const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 200);
      camera.position.set(0, 6, 8);
      camera.lookAt(0, 0, -10);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(innerWidth, innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambient = new THREE.AmbientLight(0x334455, 1.0);
      scene.add(ambient);

      const spot = new THREE.SpotLight(0xffffff, 3.5, 60, Math.PI / 5, 0.5, 1);
      spot.position.set(0, 20, -12);
      spot.target.position.set(0, 0, -12);
      spot.castShadow = true;
      spot.shadow.mapSize.set(1024, 1024);
      scene.add(spot);
      scene.add(spot.target);

      // A subtle secondary fill
      const fill = new THREE.PointLight(0x00ffc8, 0.8, 40);
      fill.position.set(0, 10, 0);
      scene.add(fill);

      // ─────────────────────────────────────────────
      //  STARTING PLATFORM
      // ─────────────────────────────────────────────
      const platformGeo = new THREE.BoxGeometry(5, 0.3, 3);
      const platformMat = new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.2, roughness: 0.1 });
      const platform = new THREE.Mesh(platformGeo, platformMat);
      platform.position.set(0, BRIDGE_Y - 0.15, START_Z);
      platform.receiveShadow = true;
      scene.add(platform);

      // ─────────────────────────────────────────────
      //  PLAYER (Participant 107)
      // ─────────────────────────────────────────────
      const player = new THREE.Group();

      // Body — cylinder
      const bodyGeo = new THREE.CylinderGeometry(0.35, 0.3, 1.0, 8);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x009688, roughness: 0.6 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 0.9;
      body.castShadow = true;
      player.add(body);

      // Head — sphere
      const headGeo = new THREE.SphereGeometry(0.25, 12, 12);
      const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.7 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.65;
      head.castShadow = true;
      player.add(head);

      // Legs — two thin cylinders
      for (let s = -1; s <= 1; s += 2) {
        const legGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 6);
        const leg = new THREE.Mesh(legGeo, bodyMat);
        leg.position.set(s * 0.15, 0.25, 0);
        leg.castShadow = true;
        player.add(leg);
      }

      // Arms — two thin cylinders
      for (let s = -1; s <= 1; s += 2) {
        const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.55, 6);
        const arm = new THREE.Mesh(armGeo, bodyMat);
        arm.position.set(s * 0.45, 1.0, 0);
        arm.rotation.z = s * 0.2;
        arm.castShadow = true;
        player.add(arm);
      }

      // Number badge — 107
      const badgeCanvas = document.createElement('canvas');
      badgeCanvas.width = 64; badgeCanvas.height = 32;
      const ctx = badgeCanvas.getContext('2d');
      ctx.fillStyle = '#37474f'; // Blue-grey 800 (Much darker)
      ctx.fillRect(0, 0, 64, 32);
      ctx.fillStyle = '#cfd8dc'; // Blue-grey 100 (Light text)
      ctx.font = 'bold 22px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('107', 32, 17);
      const badgeTex = new THREE.CanvasTexture(badgeCanvas);
      const badgeGeo = new THREE.PlaneGeometry(0.35, 0.18);
      const badgeMat = new THREE.MeshBasicMaterial({ map: badgeTex, transparent: true });
      const badge = new THREE.Mesh(badgeGeo, badgeMat);
      badge.position.set(0, 1.05, 0.36);
      player.add(badge);

      player.position.set(0, BRIDGE_Y, START_Z);
      scene.add(player);

      // ─────────────────────────────────────────────
      //  GLASS PANEL MATERIAL
      // ─────────────────────────────────────────────
      function makeGlassMat() {
        return new THREE.MeshPhysicalMaterial({
          color: 0xFFD700, // Gold/Yellow
          emissive: 0x664400, // Brighter emissive
          transparent: true,
          opacity: 0.6, // More opaque
          roughness: 0.1,
          metalness: 0.1,
          transmission: 0.6,
          thickness: 0.3,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          side: THREE.DoubleSide,
        });
      }

      // ─────────────────────────────────────────────
      //  BRIDGE GENERATION
      // ─────────────────────────────────────────────
      function buildBridge() {
        // Remove old panels
        bridgeData.forEach(row => {
          if (row.meshLeft) { scene.remove(row.meshLeft); row.meshLeft.geometry.dispose(); }
          if (row.meshRight) { scene.remove(row.meshRight); row.meshRight.geometry.dispose(); }
        });
        bridgeData = [];

        const panGeo = new THREE.BoxGeometry(PANEL_SIZE, 0.12, PANEL_SIZE);

        for (let r = 0; r < ROWS; r++) {
          const leftSafe = Math.random() < 0.5;
          const z = -r * GAP_Z;

          const mL = new THREE.Mesh(panGeo, makeGlassMat());
          mL.position.set(-COL_OFFSET, BRIDGE_Y, z);
          mL.receiveShadow = true;
          mL.castShadow = true;
          mL.userData = { row: r, col: 'left', safe: leftSafe };
          scene.add(mL);

          const mR = new THREE.Mesh(panGeo, makeGlassMat());
          mR.position.set(COL_OFFSET, BRIDGE_Y, z);
          mR.receiveShadow = true;
          mR.castShadow = true;
          mR.userData = { row: r, col: 'right', safe: !leftSafe };
          scene.add(mR);

          bridgeData.push({ leftSafe, meshLeft: mL, meshRight: mR });
        }
      }

      // ─────────────────────────────────────────────
      //  PARTICLE SHARDS
      // ─────────────────────────────────────────────
      let shards = [];

      function spawnShards(pos) {
        const count = 12;
        const geo = new THREE.BoxGeometry(0.15, 0.03, 0.15);
        for (let i = 0; i < count; i++) {
          const mat = new THREE.MeshBasicMaterial({
            color: 0x66eedd,
            transparent: true,
            opacity: 0.8,
          });
          const m = new THREE.Mesh(geo, mat);
          m.position.copy(pos);
          m.position.x += (Math.random() - 0.5) * 1.4;
          m.position.z += (Math.random() - 0.5) * 1.4;
          m.position.y += Math.random() * 0.3;
          m.userData.vx = (Math.random() - 0.5) * 2;
          m.userData.vy = Math.random() * 2 + 1;
          m.userData.vz = (Math.random() - 0.5) * 2;
          m.userData.life = 1.0;
          scene.add(m);
          shards.push(m);
        }
      }

      function updateShards(dt) {
        for (let i = shards.length - 1; i >= 0; i--) {
          const s = shards[i];
          s.userData.vy -= 9.8 * dt;
          s.position.x += s.userData.vx * dt;
          s.position.y += s.userData.vy * dt;
          s.position.z += s.userData.vz * dt;
          s.rotation.x += dt * 5;
          s.rotation.z += dt * 3;
          s.userData.life -= dt * 1.2;
          s.material.opacity = Math.max(0, s.userData.life);
          if (s.userData.life <= 0) {
            scene.remove(s);
            s.geometry.dispose();
            s.material.dispose();
            shards.splice(i, 1);
          }
        }
      }

      // ─────────────────────────────────────────────
      //  100 DOLLAR BILL PARTICLES (SUCCESS)
      // ─────────────────────────────────────────────
      let bills = [];

      function spawnBills() {
        const count = 300; // 지폐 개수를 300개로 2배 증가
        const geo = new THREE.PlaneGeometry(0.3, 0.15); // 지폐 비율 (약 2:1)
        const mat = new THREE.MeshBasicMaterial({
          color: 0x85BB65, // 미국 지폐 (그린백) 색상
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide
        });

        for (let i = 0; i < count; i++) {
          const m = new THREE.Mesh(geo, mat);

          // 배치: Y축 높이를 크게 올려 오랫동안 떨어지게 만듦 (10~40 구간)
          m.position.x = (Math.random() - 0.5) * 15;
          m.position.y = 10 + Math.random() * 30; // 시작 높이 대폭 상향
          m.position.z = player.position.z - 10 + (Math.random() - 0.5) * 20;

          // 랜덤 회전값 지정
          m.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            Math.random() * Math.PI
          );

          // 속도: 천천히 하늘하늘 떨어지도록 vy(-0.5 ~ -1.5)로 조정
          m.userData.vy = -(Math.random() * 1.0 + 0.5);
          m.userData.rx = (Math.random() - 0.5) * 2;
          m.userData.ry = (Math.random() - 0.5) * 2;
          m.userData.rz = (Math.random() - 0.5) * 2;
          m.userData.drift = (Math.random() - 0.5) * 1.5; // 좌우 살랑거림

          scene.add(m);
          bills.push(m);
        }
      }

      function updateBills(dt) {
        if (bills.length === 0) return;
        const time = clock.getElapsedTime();

        for (let i = bills.length - 1; i >= 0; i--) {
          const b = bills[i];
          b.position.y += b.userData.vy * dt;
          b.position.x += Math.sin(time * 2 + i) * b.userData.drift * dt; // 흔들리며 떨어짐

          b.rotation.x += b.userData.rx * dt;
          b.rotation.y += b.userData.ry * dt;
          b.rotation.z += b.userData.rz * dt;

          // 바닥(Y=0) 이하로 떨어졌거나 일정 시간 지나면 제거
          if (b.position.y < -2) {
            scene.remove(b);
            bills.splice(i, 1);
          }
        }
      }


      // ─────────────────────────────────────────────
      //  WEB AUDIO
      // ─────────────────────────────────────────────
      let audioCtx;
      function initAudio() {
        if (!audioCtx) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (AudioContext) {
            audioCtx = new AudioContext();
          }
        }
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
      }

      function playFallingTone() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(900, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 1.2);
        gain.gain.setValueAtTime(0.35, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 1.4);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 1.5);
      }

      function playSuccessChime() {
        if (!audioCtx) return;
        const notes = [523.25, 659.25, 783.99, 1046.5];
        notes.forEach((freq, i) => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0.25, audioCtx.currentTime + i * 0.15);
          gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + i * 0.15 + 0.4);
          osc.connect(gain).connect(audioCtx.destination);
          osc.start(audioCtx.currentTime + i * 0.15);
          osc.stop(audioCtx.currentTime + i * 0.15 + 0.5);
        });
      }

      function playSafeStep() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 600;
        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);
        osc.connect(gain).connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.2);
      }

      // ─────────────────────────────────────────────
      //  JUMP ANIMATION & GAMEPLAY
      // ─────────────────────────────────────────────
      let jumpAnim = null;   // {start, end, t, callback}
      let fallAnim = null;

      function animateJump(targetX, targetZ, onComplete) {
        jumping = true;
        jumpAnim = {
          sx: player.position.x,
          sz: player.position.z,
          sy: player.position.y,
          tx: targetX,
          tz: targetZ,
          t: 0,
          onComplete,
        };
      }

      function updateJump(dt) {
        if (!jumpAnim) return;
        jumpAnim.t += dt / JUMP_DURATION;
        if (jumpAnim.t >= 1) jumpAnim.t = 1;

        const t = jumpAnim.t;
        // Smooth ease
        const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        player.position.x = jumpAnim.sx + (jumpAnim.tx - jumpAnim.sx) * ease;
        player.position.z = jumpAnim.sz + (jumpAnim.tz - jumpAnim.sz) * ease;
        // Arc up
        const arc = Math.sin(t * Math.PI) * 1.5;
        player.position.y = BRIDGE_Y + arc;

        if (jumpAnim.t >= 1) {
          player.position.y = BRIDGE_Y;
          const cb = jumpAnim.onComplete;
          jumpAnim = null;
          if (cb) cb();
        }
      }

      function startFall() {
        fallAnim = { vy: 0, t: 0 };
        playFallingTone();
      }

      function updateFall(dt) {
        if (!fallAnim) return;
        fallAnim.vy -= 14 * dt;
        player.position.y += fallAnim.vy * dt;
        player.rotation.x += dt * 3;
        fallAnim.t += dt;

        if (fallAnim.t > 2.0) {
          fallAnim = null;
          player.rotation.x = 0;
          onFallComplete();
        }
      }

      function onFallComplete() {
        lives--;
        hudLives.textContent = lives;
        if (lives <= 0) {
          gameActive = false;
          gameoverOvl.classList.add('active');
          return;
        }
        // Respawn to start or last safe step
        respawnPlayer();
        jumping = false;
      }

      function respawnPlayer() {
        if (currentStep > 0) {
          const prevRow = bridgeData[currentStep - 1];
          const safeX = prevRow.leftSafe ? -COL_OFFSET : COL_OFFSET;
          const safeZ = -(currentStep - 1) * GAP_Z;
          player.position.set(safeX, BRIDGE_Y, safeZ);
        } else {
          player.position.set(0, BRIDGE_Y, START_Z);
        }
      }

      // ─────────────────────────────────────────────
      //  INPUT HANDLERS (MOUSE & KEYBOARD)
      // ─────────────────────────────────────────────
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Instructions Helper - REMOVED (Instructions are now in the side panel)
      /*
      const hintDiv = document.createElement('div');
      hintDiv.style.position = 'fixed';
      hintDiv.style.bottom = '40px';
      hintDiv.style.width = '100%';
      hintDiv.style.textAlign = 'center';
      hintDiv.style.color = '#fff';
      hintDiv.style.opacity = '0.6';
      hintDiv.style.fontFamily = 'sans-serif';
      hintDiv.style.fontSize = '14px';
      hintDiv.innerText = "Make your choice: Click Left/Right Glass or use ← / → Keys";
      document.body.appendChild(hintDiv);
      */

      // 1. Mouse Hover Effect
      window.addEventListener('mousemove', (e) => {
        if (!gameActive || jumping) {
          document.body.style.cursor = 'default';
          return;
        }
        mouse.x = (e.clientX / innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const row = bridgeData[currentStep];
        if (!row) return;
        const targets = [row.meshLeft, row.meshRight].filter(Boolean);
        const hits = raycaster.intersectObjects(targets);

        // Reset all emissive
        bridgeData.forEach(r => {
          if (r.meshLeft) r.meshLeft.material.emissive.setHex(0x000000);
          if (r.meshRight) r.meshRight.material.emissive.setHex(0x000000);
        });

        if (hits.length > 0) {
          document.body.style.cursor = 'pointer';
          hits[0].object.material.emissive.setHex(0x224444);
        } else {
          document.body.style.cursor = 'default';
        }
      });

      // 2. Mouse Click
      window.addEventListener('click', (e) => {
        if (!gameActive || jumping) return;
        mouse.x = (e.clientX / innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);

        const row = bridgeData[currentStep];
        if (!row) return;

        const targets = [row.meshLeft, row.meshRight].filter(Boolean);
        const hits = raycaster.intersectObjects(targets);
        if (hits.length > 0) {
          handleMove(hits[0].object);
        }
      });

      // 3. Keyboard Input
      window.addEventListener('keydown', (e) => {
        if (!gameActive || jumping) return;
        const row = bridgeData[currentStep];
        if (!row) return;

        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
          if (row.meshLeft) handleMove(row.meshLeft);
        } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
          if (row.meshRight) handleMove(row.meshRight);
        } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
          // Jump "forward" if we are already on a panel
          if (currentStep > 0) {
            // Check player x position to decide which side they are on
            if (player.position.x < -0.1) {
              // Left side
              if (row.meshLeft) handleMove(row.meshLeft);
            } else if (player.position.x > 0.1) {
              // Right side
              if (row.meshRight) handleMove(row.meshRight);
            }
          }
        }
      });

      function handleMove(panel) {
        if (!panel) return;

        // Animate jump
        animateJump(panel.position.x, panel.position.z, () => {
          if (panel.userData.safe) {
            // Safe
            playSafeStep();
            currentStep++;
            hudStep.textContent = currentStep;
            if (currentStep >= ROWS) {
              gameActive = false;
              playSuccessChime();
              spawnBills(); // 성공 시 지폐 파티클 생성
              setTimeout(() => successOvl.classList.add('active'), 3500); // 연출을 보기 위해 딜레이를 1.5초에서 3.5초로 넉넉하게 증가
            } else {
              jumping = false;
              updateCamera();
            }
          } else {
            // Unsafe
            spawnShards(panel.position.clone());
            panel.visible = false; // Hide panel immediately
            startFall();
          }
        });
      }

      // ─────────────────────────────────────────────
      //  CAMERA FOLLOW
      // ─────────────────────────────────────────────
      function updateCamera() {
        const targetZ = player.position.z + 8;
        const targetLookZ = player.position.z - 6;
        camera._targetZ = targetZ;
        camera._lookZ = targetLookZ;
      }

      // ─────────────────────────────────────────────
      //  GAME INIT / RESET
      // ─────────────────────────────────────────────
      function initGame() {
        console.log("Initializing Game...");
        initAudio();

        lives = 3;
        currentStep = 0;
        gameActive = true;
        jumping = false;
        jumpAnim = null;
        fallAnim = null;

        hudLives.textContent = lives;
        hudStep.textContent = currentStep;

        // Reset player
        player.position.set(0, BRIDGE_Y, START_Z);
        player.rotation.set(0, 0, 0);

        // Clean shards and bills
        shards.forEach(s => { scene.remove(s); s.geometry.dispose(); s.material.dispose(); });
        shards = [];
        bills.forEach(b => scene.remove(b));
        bills = [];

        buildBridge();

        // Camera
        camera.position.set(0, 6, 8);
        camera._targetZ = 8;
        camera._lookZ = -6;

        // Hide all overlays
        startOvl.classList.remove('active');
        successOvl.classList.remove('active');
        gameoverOvl.classList.remove('active');
      }

      // Button listeners
      document.getElementById('btn-start').onclick = function () {
        console.log("Start Button Clicked");
        try {
          initGame();
        } catch (e) {
          alert("Error starting game: " + e.message);
          throw e;
        }
      };
      document.getElementById('btn-replay-win').onclick = initGame;
      document.getElementById('btn-replay-lose').onclick = initGame;

      // ─────────────────────────────────────────────
      //  ANIMATION LOOP
      // ─────────────────────────────────────────────
      const clock = new THREE.Clock();

      function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.05);

        updateJump(dt);
        updateFall(dt);
        updateShards(dt);
        updateBills(dt); // 지폐 애니메이션 업데이트

        // Smooth camera follow
        if (camera._targetZ !== undefined) {
          camera.position.z += (camera._targetZ - camera.position.z) * 2 * dt;
          // Smooth the look direction
          camera._lookZ += ((player.position.z - 6) - camera._lookZ) * 2 * dt;
          camera.lookAt(0, 0.5, camera._lookZ);
        }

        // Gentle panel glow animation
        const time = clock.getElapsedTime();
        bridgeData.forEach((row, i) => {
          if (row.meshLeft && row.meshLeft.visible) {
            row.meshLeft.material.opacity = 0.35 + 0.1 * Math.sin(time * 1.5 + i);
          }
          if (row.meshRight && row.meshRight.visible) {
            row.meshRight.material.opacity = 0.35 + 0.1 * Math.sin(time * 1.5 + i + 1);
          }
        });

        renderer.render(scene, camera);
      }
      animate();

      // ─────────────────────────────────────────────
      //  RESIZE HANDLER
      // ─────────────────────────────────────────────
      window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      // Auto-focus window for key events if needed
      window.focus();

    }; // End of initApp
  </script>
</body>

</html>